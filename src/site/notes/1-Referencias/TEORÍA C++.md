---
{"dg-publish":true,"permalink":"/1-Referencias/TEORÍA C++/","title":"TEORÍA C++","noteIcon":""}
---


INDICE:

```table-of-contents
style: nestedList       # TOC style (nestedList|inlineFirstLevel)
maxLevel: 0             # Include headings up to the speficied level
includeLinks: true      # Make headings clickable
debugInConsole: true    # Print debug info in Obsidian console
```

Nota con cosas extra que no hemos dado como tal en la carrera:
[[1-Referencias/Extra Learning C++\|Extra Learning C++]]

# Teoría Organizada

## Compilación, Include, Namespace

[Headers and Includes: Why and How - C++ Articles](https://cplusplus.com/articles/Gw6AC542/)

- Es necesario compilar el codigo fuente en codigo maquina
- g++ es el compilador, lo convierte en un fichero ejecutable.
- Diferencias: python mas lento pero facil de escribir. C++ permite hacer operaciones de bajo nivel, es más eficiente (espacio y tiempo), código preciso para ciertas acciones.
    - Python te ahorraba tener que indicar el tipo de variable.

- **FORMAS DE COMPILAR**;
	- 1)  Directamente en exe
		- ``g++ principal.cpp auxiliar.cpp -o programa.exe``
	- 2)  Primero objetos, luego linkeado en exe
		- ``g++ -c auxiliar.cpp``
		- ``g++ -c principal.cpp``
		- `g++ principal.o auxiliar.o -o programa.exe` (enlace)
	- La ventaja del 2 es que obtenemos los .o y ante cambios no habrá que recompilarlo todo

- En qué convierte el compilador un codigo fuente?
	- En archivos de objeto llamados tipicamente *nombre.o* o nombre.obj.
	- En binario, leíble por la compu

- **HPP (HEADER FILES)**
	- Archivos que contienen las declaraciones de las funciones y clases.
	- Se deben incluir en todos los archivos que se vayan a compilar
	- The **.h** file declares code, and the **.cpp** file implements that declaration
	- tienen extension .h o .hpp.
	- No se compilan, se incluyen en los módulos usados. Al contrario que .cpp

- *LINKER*
	- Takes all the object files generated by the compiler and {; combines} them into a single executable program.

- *g++ hace*:
	- preproceso (includes), la compilacion, enlazado (genera el ejecutable y junta los compilados).
	- ![2023-09-14_14-07-07_pre_comp_link.png](/img/user/_Archivos/2023-09-14_14-07-07_pre_comp_link.png)


- ``#include <headerfile>``
	- Include es una directiva, se sustituye con los contenidos del archivo incluido.
	- se puede separar el código en varios archivos. Se detecta y se compila todo junto.
	- Usar ``#include <iostream>`` para agregar objetos de entrada y salida. (cin, cout)

- **Header guards: IFNDEF Y DEFINE**
	- Son directivas que se usan para evitar incluir varias veces el mismo archivo header.
	- *Todos los headers deben tenerlos*.
	- ``#ifndef NAME`` Mira si un identificador {; no está incluido}, entonces, el codigo hasta ``#endif`` será compilado
	- ``#define NAME`` Marca el header como incluido.

- espacio de Nombres
	- Escribir las funciones del .hpp file dentro de un bloque como "namespace misfunciones" ayuda a que las funciones definidas dentro de él no sean confundidas con funciones con el mismo nombre de fuera de él.
	- Para crear o usar las funciones ahora deberemos acceder a ellas mediante misfunciones::funcion

	- Obviamente dentro de un namespace todas las funciones deben tener distinto nombre

	- Un ejemplo de espacio de nombres es std, usado en cout, string...
	- *using namespace std*  -> nos permite acceder a lo de std sin mencionarilo con su prefijo, puede causar conflictos

## Git

``git add .``
``git commit -m "TEXTO"``
``git push``

``git clone "url_repositorio"``
- usuario y token
``git config--global ...``

## Estructuras De Datos

- VECTORES

	- *OPERACIONES BÁSICAS*

		- Needs: `#include <vector>`
		- *Create*
			- ``std::vector<int> v;``  (vacio)
			- ``std::vector<int> v2 = { 2, 3, 5, 7 }``
		- *Access* elements
			- ``v[0]``
				- Careful, because the compiler won't detect if index is incorrect
			- ``v.at(1)``  hace la comprobación de sí el indice está dentro de los limites, genera una excepción si no lo está (usar try-catch)
		- Vector containing x elements with y value
			- ``std::vector<int> data( 10 );``  (default value: 0)
			- ``std::vector<int> vector3(5, 12);`` (5 elements with value 12)
		- Constant vector
			- ``const std::vector<int> prime { 2, 3, 5, 7, 11 };``
			- Not allowed: ``std::vector<const int> prime { 2, 3, 5, 7, 11 };``  (elements of a non-const vector must be non-const)
		- *Add* elements
			- ``v.push_back(6)``
		- *Delete last* element
			- ``v.pop_back()``
		- *Tamaño* (cantidad elementos)
			- `v.size()`
		- *Recorrer vector*
			- `for (int i = 0; i < v.size(); ++i)`
		- *Ordenar vector*
		- Other functions
			- clear()
			- front()     returns first element
			- back()      last element
			- empty()   boolean
			- capacity()   overall size
		- *Passing parameters by reference and keep it constant*
			- `(const std::vector<int>& v)`
		- Copying an array (independent)
			- `std::vector arr2 { arr1 };`

	- *Reserva de memoria*
		- Interesante si conoces cuantos contendrá
		- `miVector.reserve(100);`

- [CADENAS](https://cplusplus.com/reference/string/string/)

	- Concatenar
		- `std::string result = str1 + str2;`
	- *Convertir número a string*
		- `std::string str = std::to_string(number);`
	- Longitud
		- ``cadena.length()`` o ``cadena.size()``
	- Acceso a elementos o modificar
		- ``c[1]="a"``
			- Esto en python no se puede, pero aquí sí

- MAPS (diccionarios)

	```cpp
	#include <iostream>
	#include <map>
	#include <string>
	#include <utility>  // Para usar make_pair
	
	// Las claves deben ser únicas
	// Se almacenan ordenados por clave
	
	
	int main() {
	    // 1. Creating a Map
	    std::map<int, std::string> studentMap;
		std::map<const int, int> mapaClave    // Clave invariable
		std::map<int, string> student = { {1,"Jacqueline"}, {2,"Blake"}, {3,"Denise"}}
	
	    // 2. Inserting Key-Value Pairs
	    studentMap[101] = "Alice";
	    studentMap[102] = "Bob";
	    studentMap[103] = "Charlie";
	    studentMap.insert(std::make_pair(104, "Juan"))
	
	    // 3. Accessing Values by Key
	    int studentID = 102;
	    std::string studentName = studentMap[studentID];
	    std::cout << "3. Accessing by Key: Student " << studentID << ": " << studentName << std::endl;
	
	    // 4. Checking if a Key Exists
	    int searchID = 104;
	    if (studentMap.find(searchID) != studentMap.end()) {
	        std::cout << "4. Key " << searchID << " exists." << std::endl;
	    } else {
	        std::cout << "4. Key " << searchID << " does not exist." << std::endl;
	    }
	
	    // 5. Iterating Through the Map
	    std::cout << "5. Iterating Through the Map:" << std::endl;
	    for (std::pair <const int, string> item : studentMap) {
	        std::cout << "   Student " << item.first << ": " << item.second << std::endl;
	    }
		    // Con esto se crea un mapa a partir del diccionario, podemos modificar los valores del mapa, pero no el diccionario como tal
	
	    // 6. Removing a Key-Value Pair
	    int removeID = 101;
	    studentMap.erase(removeID);
	    std::cout << "6. Removing a Key-Value Pair: Student " << removeID << " removed." << std::endl;
	
	    // 7. Checking the Size of the Map
	    size_t mapSize = studentMap.size();
	    std::cout << "7. Size of the Map: " << mapSize << " students remaining." << std::endl;
	
	    return 0;
	}
	```

- Conjuntos (sets)

	```cpp
	#include <iostream>
	#include <set>        // Importante
	using namespace std;
	
	int main() {
	    // Create a set
	    std::set<int> mySet;
	
	    // Insert elements
	    mySet.insert(5);
	    mySet.insert(3);
	    // If an element is already added, it will be ignored.
	    mySet.insert(5);
	
	    // Print the set
	    cout << "The elements of the set are: ";
	    for (auto it = mySet.begin(); it != mySet.end(); ++it) {
	        cout << *it << " ";
	    }
	    cout << endl;
	
	    // Erase an element
	    mySet.erase(3);
	
	    // Print the set after erasing
	    cout << "The elements of the set after erasing 3 are: ";
	    for (auto it = mySet.begin(); it != mySet.end(); ++it) {
	        cout << *it << " ";
	    }
	    cout << endl;
	
	    // Check if the set is empty
	    if (mySet.empty()) {
	        cout << "The set is empty." << endl;
	    } else {
	        cout << "The set is not empty." << endl;
	    }
	
	    // Get the size of the set
	    cout << "The size of the set is: " << mySet.size() << endl;
	
	    // Find an element in the set
	    auto search = mySet.find(2);
	    if (search != mySet.end()) {
	        cout << "Found " << *search << '\n';
	    } else {
	        cout << "Not found\n";
	    }
	
	    // Clear the set
	    mySet.clear();
	    
	    return 0;
	}
	```

## Entrada y Salida, Ficheros

- **STRING**

	```cpp
	#include <iostream>
	#include <string>
	
	int main() {
	    // 1. Creating and Initializing Strings
	    std::string str1 = "Hello, ";
	    std::string str2 = "world!";
	    
	    // 2. Concatenating Strings
	    std::string greeting = str1 + str2;
	    std::cout << "1. Concatenating Strings: " << greeting << std::endl;
	
	    // 3. String Length
	    std::string text = "This is a sample text.";
	    int length = text.length();
	    std::cout << "2. String Length: " << length << " characters." << std::endl;
	
	    // 4. Accessing Characters
	    char firstChar = text[0];
	    char lastChar = text[length - 1];
	    std::cout << "3. Accessing Characters: First: " << firstChar << ", Last: " << lastChar << std::endl;
	
	    // 5. Substring
	    std::string substring = text.substr(5, 6); // Starting from index 5, take 6 characters
	    std::cout << "4. Substring: " << substring << std::endl;
	
	    // 6. Find and Replace
	    std::string sentence = "Replace the word 'world' with 'universe' in this sentence.";
	    std::string target = "world";
	    std::string replacement = "universe";
	    size_t found = sentence.find(target);
	    if (found != std::string::npos) {
	        sentence.replace(found, target.length(), replacement);
	    }
	    std::cout << "5. Find and Replace: " << sentence << std::endl;
	
	    // 7. Compare Strings
	    std::string str3 = "apple";
	    std::string str4 = "banana";
	    int comparisonResult = str3.compare(str4);
	    if (comparisonResult < 0) {
	        std::cout << "6. Compare Strings: " << str3 << " comes before " << str4 << std::endl;
	    } else if (comparisonResult > 0) {
	        std::cout << "6. Compare Strings: " << str3 << " comes after " << str4 << std::endl;
	    } else {
	        std::cout << "6. Compare Strings: " << str3 << " is equal to " << str4 << std::endl;
	    }
	
	    return 0;
	}
	```

- **STD::COUT, CIN, ENDL, GETLINE**

	```cpp
	#include <iostream>
	#include <string>
	
	int main() {
	    // 1. Output using std::cout
	    int x = 42;
	    std::cout << "1. Output using std::cout: x is equal to: " << x << std::endl;
	
	    // 2. Output with std::endl
	    std::cout << "2. Output with std::endl: Hi!" << std::endl;
	
	    // 3. Input using std::cin
	    int y;
	    std::cout << "3. Input using std::cin: Enter a value for y: ";
	    std::cin >> y;
	    std::cout << "You entered: " << y << std::endl;
	
	    // 4. Input of multiple data in a single line
	    double a, b;
	    std::cout << "4. Input of multiple data in a single line: Enter values for a and b: ";
	    std::cin >> a >> b;
	    std::cout << "You entered a = " << a << " and b = " << b << std::endl;
	
	    ///// 5. Get entire lines as input
	    std::string linea;
	    std::cout << "5. Get entire lines as input: Enter a sentence: ";
	    std::cin.ignore(); // Clear the newline character left in the input buffer
	    std::getline(std::cin, linea);
	    std::cout << "You entered: " << linea << std::endl;
	
	    return 0;
	}
	``` 
	^x8aec2

- **stringstream**

	```cpp
	#include <iostream>
	#include <sstream>  // Importante
	#include <string>
	
	int main() {
	    // Creating a stringstream
	    std::stringstream ss;
	    std::ostringstream oss;
	    std::istringstream iss;
	    std::istringstream ss(text);
	    
	
	    // 1. Basic Usage: Converting Data Types to Strings
	    int num = 42;
	    double pi = 3.14159265359;
	    ss << "Integer: " << num << ", Double: " << pi;
	    std::string result = ss.str();
	    std::cout << "1. Basic Usage: " << result << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 2. Parsing Strings into Data Types
	    std::string data = "123 45.6789";
	    int parsedInt;
	    double parsedDouble;
	    ss.str(data); // Load data into stringstream
	    ss >> parsedInt >> parsedDouble;
	    std::cout << "2. Parsing Strings: Integer: " << parsedInt << ", Double: " << parsedDouble << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 3. Appending to an Existing String
	    ss << "Hello, ";
	    std::string name = "Alice";
	    ss << name << "!";
	    std::string greeting = ss.str();
	    std::cout << "3. Appending to String: " << greeting << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	
		// 4. BUCLES LECTURA DE LINEAS
		std::istringstream flujo_linea(linea);
		while (flujo_linea >> n) {
			// Do something
			// Esto agrega cada "palabra" individual a n, mientras haya
		}
	
	    // 4. Formatting Output
	    double value = 1234.5678;
	    ss << "Value: " << std::fixed << std::setprecision(2) << value;
	    std::string formattedValue = ss.str();
	    std::cout << "4. Formatting Output: " << formattedValue << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 5. Extracting a Substring
	    std::string longText = "This is a long sentence.";
	    ss.str(longText);
	    std::string subString;
	    ss >> subString;
	    std::cout << "5. Extracting Substring: " << subString << std::endl;
	
	    return 0;
	}
	```

- **Ficheros**

	```cpp
	#include <iostream>
	#include <fstream>   // Importante
	#include <string>
	
	int main() {
	    // Create a file object for output
	    std::ofstream outFile("output.txt");
	
	    // Check if the file opened successfully
	    if (outFile) {
	        // Write data to the file
	        outFile << "Hello, Files!" << std::endl;
	
	        // Close the file
	        outFile.close();
	    } else {
	        std::cerr << "Error opening the file." << std::endl;
	    }
	
	    // Create a file object for input
	    std::ifstream inFile("input.txt");
	
	    // Check if the file opened successfully
	    if (inFile) {
	        std::string line;
	        // Read the file line by line
	        while (std::getline(inFile, line)) {
	            if (!line.empty()) {
	                std::cout << "Line: " << line << std::endl;
	            }
	        }
	
	        // Close the file
	        inFile.close();
	    } else {
	        std::cerr << "Error opening the file." << std::endl;
	    }
	
	    return 0;
	}
	
	```

- **NAN**

	```cpp
	#include <iostream>
	#include <cmath>   // importante
	
	int main() {
	    // Create a NAN value
	    double nanValue = std::nan("");
	
	    // Check if a value is NAN
	    if (std::isnan(nanValue)) {
	        std::cout << "The value is NAN." << std::endl;
	    } else {
	        std::cout << "The value is not NAN." << std::endl;
	    }
	    return 0;
	}
	```

- **SETW**, LEFT AND RIGHT

	`#include <iomanip>`
	`outFile << std::setw(10) << "Name" << std::setw(10) << std::endl;`

	- Lo que hace es indicar que la columna ocupara X caracteres, alinea el texto a la derecha

	*seek* (no lo hemos dado)

	- [28.7 — Random file I/O – Learn C++](https://www.learncpp.com/cpp-tutorial/random-file-io/)

## T2. Técnicas de caja negra y blanca

- Si el programa de pruebas está mal, es que la tabla de casos y escenarios deben ser corregidas.

- CPPUNIT

	- Clase y programa en un fichero
	- Agrupar pruebas en clase TestFixture con TestSuite
	- No es necesario usar un método de prueba distinto para cada caso de prueba si hay muchos.
	- Lanzador con salida por consola
	- `g++ AAA_test.o AAA.o -lcppunit -o AAA_test`

- OBJETIVOS
	- Pruebas de Unidad: Funciones o clases
	- Un programador debe evitar probar su propio programa
	- Prever condiciones inválidas
	- Evita improvisar los casos de prueba
	- El estado mental correcto es asumir que habrá errores.

	- Técnica FIRST:
		- Fast (rápido): Ejecución frecuente de los tests
		- Independent (independiente): El orden de los tests no debe de afectar al resultado
		- Repeatable (repetible): Independiente del servidor, configuración...
		- Self-validating (auto evaluable): Booleano como resultado, no debemos comprobar el resultado de los tests de forma manual.
		- Timely (oportuno): Hacer las pruebas antes de desarrollar el programa

- **TÉCNICAS DE CAJA NEGRA**

	- Comprobar el comportamiento sin conocer su implementación interna (Resultados externos)
	- Sirven para definir un conjunto de ESCENARIOS

	```cpp
	 1    int f(int a, int b) {
	 2        if (a > 10) {            // D1
	 3            a += 10;
	 4        }
	 
	 5        if (a > 2 and b > 2) {   // D2 (D2.1 y D2.2)
	 6            return a * b;
	 7        } else {
	 8            return a + b;
	 9        }
	10    }
	```

	- **TABLA DE ESCENARIOS**

		- Situaciones generales donde queremos probar el programa.
		- Un escenario es inválido si no se cumplen las precondiciones.
		- Los escenarios pueden estar en funcion de 1 entrada, relaciones de varias entrada, o de salida.
		- No todo escenario va a acabar convirtiéndose en una prueba específica.

		- Posibles escenarios:
			- Equilatero, Isosceles, Escaleno, No es un triangulo
			- La decisión del if de la línea 10 del método llega a tomar el valor false

		- *Planteamiento de escenarios*
			- escenarios basados en las entradas
				- En números, negativos, 0, positivos
			- escenarios basados en las relaciones entre las diferentes entradas
				- a > b+c
			- escenarios basados en las posibles salidas
			- escenarios basados en la relación entre entradas y salidas

		- *Escenarios inválidos vs válidos*
			- Cada escenario inválido ha de ser cubierto con un caso de prueba específico que no cubra ningún otro escenario inválido
			- En escenarios válidos, cubrir cuantos más mejor

		- Prefijos
			- V o I según valido o invalido

		- TABLA ESCENARIOS EJEMPLO
			- ![2023-10-13_16-12-00_escenarios_tabla.png](/img/user/_Archivos/2023-10-13_16-12-00_escenarios_tabla.png)

	- **TABLA DE CASOS**
		- ![2023-10-13_16-02-46_casosprueba.png](/img/user/_Archivos/2023-10-13_16-02-46_casosprueba.png)
		- Casos concretos (*completamente especificados*) usados para comprobar el programa.
			- a = 7,    b = 8,    salida true
		- Con pocos casos de prueba cubrimos muchos escenarios.
		- Se puede dividir la entrada en subcolumnas





- **TÉCNICAS DE CAJA BLANCA**

	- DEFINICIÓN Y CONCEPTOS
		- A diferencia de la caja negra, aquí nos dejamos guiar por el código que queremos probar. Prueban la estructura interna y la lógica de un código, sabiendo como funciona por dentro.
		- No tenemos en cuenta codigos validos o invalidos, simplemente queremos probar todo el codigo.
		- Deberemos hacer *diferentes casos de prueba para que se cubran todas las posibles coberturas*

	- POSIBLES COBERTURAS:      `c1 or (c2 and c3)`
		- Cobertura de sentencias
			- Todas cubiertas al menos una vez
			- Ejemplo, un if sin else, o se cubre la sentencia o no se cubre
		- Escenarios de cobertura de *decisiones*
			- (un test que cubra ejemplos para todos los "if" por ejemplo *al menos una vez con true y false*)
			- Ignoramos la complejidad y los operadores lógicos, solo nos importa true o false.
			- D1T, D2F
		- Cobertura de *condiciones*
			- Son los elementos más pequeños, unidos con "or", "and"...
			- D1.1F, D1.2T, D1.3T, D1.3F ...
			- C1T, C1F, C2T, C2F, C3T, C3F
			- 2^n escenarios para n condiciones
		- Cobertura de *condición múltiple*
			- Tablas de verdad para cada decisión.
			- D1TXX, D1FTT, D1FTF, D1FFX
			- C++ es en *circuito corto*, por lo que a veces es inutil seguir comprobando si ya se cumple.



	- *CAJA BLANCA EJEMPLO*:
		```cpp
		int CountNumbers(const std::string& s) {
		    int n = 0;
		    bool out_before = true;
		    for (int i = 0; i < s.length(); ++i) {
		        if (s.at(i) >= '0' and s[i] <= '9') { // now in a number
		            if (out_before) {
		                ++n;
		                out_before = false;
		            }
		        } else {
		            out_before = true;
		        }
		    }
		    return n;
		}
		```


		- **TABLA DE DECISIONES**
			![2023-10-27_20-20-11_.png|409](/img/user/_Archivos/2023-10-27_20-20-11_.png)
			- Error: `1 < s.length()` es` i < s.length()`
			- *Decisión*: todo lo de dentro de un if
			- *Escenarios*: (T/F) para cada decisión
			- Al hablar de un escenario concreto (Como D1F) queremos decir las situaciones en las que al ejecutar el programa se cumplirá ese escenario concreto al menos una vez. D1F -> siempre, indica que en la ejecución del programa, independentemente de cadena introducida, siempre se llegará a cumplir. En este programa se debe a que el bucle for va decrementando la i (la foto está mal es una i en lugar de 1)
	
		- **TABLA DE CASOS**
			![2023-10-27_20-19-01_.png|380](/img/user/_Archivos/2023-10-27_20-19-01_.png)
			- Con un solo caso cubrimos los 6 escenarios. Con esto queremos decir que al ejecutar el programa con el input "x44y9", se pasará por todos los tipos escenarios posibles para las diferentes sentencias if, while... Comprobando así la seguridad del código al no dejar nada por revisar.

	
		- **TABLA DE ESCENARIOS ---- COBERTURA DE CONDICIÓN MULTIPLE**
			![2023-10-27_20-18-16_.png|557](/img/user/_Archivos/2023-10-27_20-18-16_.png)
			- Todo lo de la tabla de decisiones anterior, pero ahora viendo cada *condición* concreta por separado.
			- *Decisiones iguales en diferentes puntos* han de ser tratadas (x>10)
	
		- **TABLA DE CASOS  -----  COBERTURA DE CONDICIÓN MULTIPLE**
			![2023-10-27_20-18-43_.png](/img/user/_Archivos/2023-10-27_20-18-43_.png)
			- Igual que la normal pero ahora según los nuevos escenarios, más posibilidades
			- Datos:
				- / esta por debajo del 0
				- : esta por encima del 9


## Excepciones

- BLOQUES TRY/CATCH

	```c++
	try {
	    // Código que podría lanzar una excepción
	} catch (const std::runtime_error& e) {
	    // Manejar excepción de std::runtime_error
	} catch (const std::exception& e) {
	    // Manejar excepción genérica de std::exception
	}
	
	```

- LANZAR
	- `throw std::invalid_argument("elements is empty");`

- UNITTEST
	- `CPPUNIT_ASSERT_THROW(funcion(), std::invalid_argument)`

## Programación Orientada a Objetos

Mirar programas ejemplo en VSCode

- **CLASES**:

	- [OOP](https://www.w3schools.com/cpp/cpp_oop.asp)
		- A class is a template for objects, and an object is an instance of a class
	- [Classes and Objects](https://www.w3schools.com/cpp/cpp_classes.asp)
		- Atributes and methods
	- [Class Methods](https://www.w3schools.com/cpp/cpp_class_methods.asp)
		- Se pueden definir fuera de la clase accediendo con Clase::Funcion(). Pero se debe declarar dentro de la clase
	- [Constructors](https://www.w3schools.com/cpp/cpp_constructors.asp)
		- Funcion que usa el mismo nombre que la clase
		- Son publicos siempre
		- No tienen valor de retorno
	- [Access Specifiers](https://www.w3schools.com/cpp/cpp_access_specifiers.asp)
		- Los atributos privados no pueden ser accedidos desde el programa principal, aunque si con un metodo publico de dentro de la clase
		- Es una buena practica declarar los atributos como privados todo lo que se pueda
	- [Encapsulation](https://www.w3schools.com/cpp/cpp_encapsulation.asp)
		- Ejemplo atributo privado: "salario"
		- No se puede acceder a él con Persona.salario
		- Pero sí se puede usar una función pública: getSalario() para acceder al salario
		- Esto ayuda a cambiar partes del código sin afectar a otras
	- [**Classes (I)**](https://cplusplus.com/doc/tutorial/classes/)
	- [**Classes (II)**](https://cplusplus.com/doc/tutorial/templates/) (salvo *templates*)
	- [**Special members**](https://cplusplus.com/doc/tutorial/classes2/)
	- [**Friendship and inheritance**](https://cplusplus.com/doc/tutorial/inheritance/) (funciones amigas)

- **Conceptos random de clases**

	- Parámetros:
		- `objeto.funcion(parametro)`
			- realmente tiene 2 parametros, el objeto y el parametro c.
		- `int Denominador() const;`
			- El const se refiere al parametro implícito, el propio objeto

- **Operation Overload

	- [c++ - What are the basic rules and idioms for operator overloading? - Stack Overflow](https://stackoverflow.com/questions/4421706/what-are-the-basic-rules-and-idioms-for-operator-overloading)

	- a += b;  a.Mas(b)
	- Nuevas posibles interpretaciones
		- operator+= (a, b)
		- a.operator+= (b)

	- flujo << a;
	  - operator<<(flujo, a)
	  - AUNQUE AHORA no tenemos lo siguiente, ya que no podemos acceder al objeto del flujo: flujo.operator<<(a)

- **PUNTEROS, memoria dinámica** ([Pointers](https://cplusplus.com/doc/tutorial/pointers/)), incrementos, new

	- BASICO

		- Es una variable que almacena una *dirección de memoria* de otra variable
		- Para ver la direccion de memoria de esta otra variable, usamos *&*
		- Se debe indicar el *tipo de dato* del dato al que apunta el puntero para poder "derreferenciarlo" cuando queremos acceder al valor que está en la dirección de memoria de este.
		- No confundir el *asterisco* que indica que es un puntero, con el asterisco para derreferenciar

		```cpp
		// CREAR Y ALMACENAR DIRECCIÓN DE MEMORIA
		`int x = 10; 
		int* ptr = &x;     // 0x6dfed4  
		
		// ACCEDER A EL VALOR DONDE ESTÁ EL PUNTERO (DERREFERENCE)
		int y = *ptr   // 10
		
		// CAMBIAR VALOR DEL PUNTERO
		*ptr = 12
		
		// SI EL PUNTERO ES UN OBJETO
		// Accedemos a un atributo del objeto con
		(*ptr).atributo
		ptr->atributo
		
		```

		- \*this es un caso concreto de puntero, que apunta a la dirección de memoria del objeto que lo invoca.

	- **SOLICITUD Y BORRADO DE MEMORIA DINÁMICA**
		- Se reserva cuando hace falta. No va asociado a ningún frame. Se tiene que liberar manualmente en el momento que corresponda.
		- Eficiente para estructuras de datos *tamaños variables*

		- Se solicita con `new`
		- Hay que indicar el tipo de dato
		- Devuelve un *puntero* al principio de la memoria que se asigna
		- Luego se inicializa el objeto.

		- Se libera con `delete`
		- Esto llama al *destructor* de la clase, que se escribirá con `~` delante del nombre de la clase.

		```cpp
		int* dynamicInt = new int;
		*dynamicInt = 42;
		
		delete dynamicInt;
		
		NodoStr *nuevo_nodo = new NodoStr(a, nullptr);
		```
	
	- *Fugas de memoria*:
		- Cuando se asigna memoria dinámica pero no se libera (usando delete)
	
	- INCREMENTO Y DECREMENTO
		 - `++ptr` o `ptr = ptr + 1` no tiene por que aumentar su valor en 1, depende de lo que ocupe el valor situado en el puntero. Simplemente va al siguiente elemento del mismo tipo
	
	- PUNTERO NULO
		- Los punteros pueden tomar el valor de cualquier dirección de memoria. El problema podría venir de intentar acceder al valor en esa dirección.
			- El `nullptr` o el `0` se encargan de hacer que el puntero no apunte a ningún sitio.

- **STRUCT**

	- Son como clases, pero sus miembros son públicos por defecto, a diferencia de las clases

- **SOBRECARGA**

	- multiple functions of different types are defined with the same name
	- mismo nombre (o símbolo) para llamar a funciones que se diferencian por su lista de parámetros (u operandos).

- **HERENCIA**

	- Tenemos clases y subclases
	- Las subclases tienen atributos en común, y pueden tener otros atributos más específicos

	- Una clase puede heredar de otra usando ":"
		- ``class Car: public Vehicle``
	- También puede heredar de varias, separandolas por ","
		- ``class Car: public Vehicle, public Object``

- **POLIMORFISMO**

	- *EJEMPLO CON PUNTEROS*: 
		- Un puntero de el tipo padre (Shape), puede contener objetos de diferentes hijos (Circle/Square)
		- Al llamar a draw de este puntero, según lo que contenga llamará a la función draw de un objeto o del otro.
		```cpp
		Shape* shape1 = new Circle(); 
		Shape* shape2 = new Square(); 
		shape1->draw(); 
		shape2->draw();
		```
	
	- Condiciones necesarias.
		- Hacer virtual el método base.
	- Slicing: Copiar objeto derivado en el hueco del objeto base, se eliminaran los atributos y métodos de la clase hija, y se quedarán las del padre
		```cpp
		Dog rex;                     // Clase hija
		Animal pet = rex;            // Se sobreescribe, ahora es objeto de la clase padre
		```


# Por Fechas

## 2023-11-29

- ARRAYS DE C Y PUNTEROS / MEMORIA DINÁMICA
	- `int foo [20];`    // Talla fija de tipo int
	- `int* foo = new int[5];`
		- Returns a pointer to the first element.
		- The first element can be accessed with `foo[0]` or  `*foo`
		- The second, with `foo[1]` or `*(foo+1)`

- `delete[] pointer;`
	- releases the memory allocated for arrays of elements using new and a size

```cpp  file:"Ejemplo Aritmétrica Punteros" hl:9
char *mychar;    // Memoria 1000
short *myshort;  // Memoria 2000
long *mylong;    // Memoria 3000

++mychar;    // +1
++myshort;   // +2
++mylong;    // +4

// Esto se debe a que sumar uno a un puntero se hace segun el tamaño del tipo de dato que contiene cada puntero. No tendría sentido sumar siempre 1 a la dirección de memoria.

// También se puede usar --
// También se pueden usar otros números a sumar o restar



*p++   // same as *(p++): increment pointer, and dereference unincremented address
*++p   // same as *(++p): increment pointer, and dereference incremented address
++*p   // same as ++(*p): dereference pointer, and increment the value it points to
(*p)++ // dereference pointer, and post-increment the value it points to 
```


- **copy and swap**
	- en c++, al hacer a=b, esperamos que `a` y `b` sigan vidas independientes
	- intercambia el contenido de dos objetos sin necesidad de copiar sus datos
	```cpp warn:2
	ListaSimple& ListaSimple::operator=(const ListaSimple& otra) {
		if (&otra != this) {
			//(this != &otra): Si hacen referencia exactamente al mismo objeto, en la misma posición de memoria, simplemente devolverlo

			// - Esto evita autoasignación, como vector1 = vector1, cosa que daría error al borrar los datos y luego intentar acceder a ellos.

			// - Lo que no evita es hacer vector1 = vector2, vector1 = vector2, vector1 = vector2...
			ListaSimple copia(otra);
			std::swap(ini_, copia.ini_);
			std::swap(fin_, copia.fin_);
			std::swap(talla_, copia.talla_);
			// ahora el objeto actual (`*this`) contiene los datos de la copia,
			// y la copia contiene los datos originales del objeto actual
		}
	// Al salir del if, se destruye automatico el objeto copia
	// con los contenidos del antiguo this
	return *this;
	}
	```



## 2023-12-13

- **COSTES**
	- COSTE PEOR CASO
	- COSTE AMORTIZADO
		- Es simplemente el coste medio.
		- Consiste en encontrar la operación más costosa y la menos costosa, y encontrar el punto medio para regularlo.
		- Esto tiene que ver con la práctica 9 de vectores, donde el peor caso para agregar un elemento era de 1, hasta que el array se tenía que duplicar, agregando todos los elementos, y luego agregar el nuevo, siendo un coste de n.
		- BOLETIN
			- es de 2\*(i-2)         el coste acumulado en los peores moomentos, donde se duplica el espaio
			- 3n -4      lineal
			- *si siempre amplias mediante una cosntante, el coste total sale cuadratico, el coste amortizado sale lineal*

- **ESQUEMAS ALGORITMICOS**        (examen practico)
	- busqueda anchura
	- divide y vencerás          (examen hasta aqui)

- algoritmos sobre grafos
	- muchos problemas son adaptar los algoritmos del recorrido sobre grafos
	- GRAFO: conjunto de vértices y aristas
	- Dado un grafo, se quiere hacer cierta tarea, recorrido...

	- Recorrido en anchura      (ejemplo algoritmo)
		- miramos cada nodo y sus vecinos, ponemos en la cola los que no hemos visto y tambien lo ponemos en vistos, luego vamos viendo todos los vecinos etc.

# Cuestiones Random

- **ONE LINE CONDITIONS**:

	- `condition ? value_if_true : value_if_false`

	- `std::cout << (veces > 1 ? " veces" : " vez")`
		- Se imprime " veces" si la variable es mayor que 1, y " vez" si no.

- POST / PRE-INCREMENTO 
	```cpp
	// PRE-INCREMENTO, antes de evaluar la expresión
	int a = 5;
	int b = ++a; // Ahora, a=6 y b=6
	// POST-INCREMENTO, después de evaluar la expresión
	int a = 5;
	int b = a++; // Ahora, a=6 y b=5
	```

- **Variables locales:**
	- Si se crean dentro de un bloque if/else por ej. solo se pueden acceder desde dentro de él

- **Pasar por referencia**
	- ``int &refNumero = numero;``  // refNumero es una referencia a numero
	- Recibiremos por **referencia `const`** todas las estructuras de datos que sean parámetros de una función (vectores, *strings*, conjuntos, diccionarios...) y no sea un objetivo específico de esa función modificar.

- **EXPRESIONES PELIGROSAS** (vectores):
	`v.size()-1`
	- PROBLEMA: Si `v` está vacío, `v.size()` vale cero y, además, es de un tipo entero sin signo, de tal forma que `0-1` en un tipo así puede dar un resultado grandísimo
	- SOLUCION: asignar `v.size()` a una variable de tipo `int` antes de restarle nada. Si la resta se hace sobre esa variable, un posible resultado negativo se calculará con completa normalidad
		```cpp  
		int i = v.size();
		--i;
		```

	`v[i]`
	- PROBLEMA: Comportamiento indefinido cuando i está fuera del rango válido
	- SOLUCION: Sustituir los accesos `v[i]` por accesos `v.at(i)`
	```cpp  
	while (not v.empty and v[i] == 0) {
	    v.pop_back();
	    --i;
	// C++ es de circuito corto: Si el 1r operando de un and es false, no se evalua el 2o.
	}
	```

- En c++ haremos *copias* al usar el =, a diferencia de python que es una asignación (en listas por ej.)

- Diferencia entre *constructores copia, y asignaciones*
	- COPIA
		- int a = 3, b = 4;
		- int a(3), b(4);
		- int a{3}, b{4};
	- ASIGNACION
		- int a{};
		- a = 3;

- `if (izq)` =  `if (izq != nullptr)`
	- Siendo izq un puntero.

