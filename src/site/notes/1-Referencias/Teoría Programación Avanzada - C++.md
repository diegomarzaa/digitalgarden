---
{"dg-publish":true,"permalink":"/1-Referencias/Teoría Programación Avanzada - C++/","title":"Teoría Programación Avanzada - C++","noteIcon":""}
---


> [!info]+ Información
> Nota con cosas extra algo más desordenadas que no hemos dado como tal en la carrera: [[1-Referencias/Conceptos Adicionales C++\|Conceptos Adicionales C++]]

> [!warning]+ Aviso
> Muchas veces se pueden asumir conocimientos básicos de otros lenguajes de programación, como python.

# Introduction

C++ es un lenguaje de programación de alto nivel que se utiliza para desarrollar aplicaciones de software. Es una extensión del lenguaje de programación C y agrega características como la programación orientada a objetos y la manipulación de memoria. C++ es ampliamente utilizado en la industria del software debido a su eficiencia y capacidad para crear programas de alto rendimiento.

Four major updates to the C++ language (C++11, C++14, C++17, and C++20)
- C++11 is typically considered the modern minimum
- Finalized language standards are named after the years in which they are finalized (e.g. C++17 was finalized in 2017).

"Trust the programmer":
C++ is designed to allow the programmer a high degree of freedom to do what they want. However, this also means the language often won’t stop you from doing things that don’t make sense, because it will assume you’re doing so for some reason it doesn’t understand.

**Puntos Positivos C++**

- excels in situations where high performance and precise control over memory and other resources is needed

**Good Practise**

When you sit down and start coding right away, you’re typically thinking “I want to do something”, so you implement the solution that gets you there the fastest. This can lead to *programs that are fragile*, hard to change or extend later, or have lots of bugs (technical defects).
*it’s worth your time to spend a little extra time up front* (before you start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.


**STATEMENTS**
- they are the smallest independent unit of computation in the C++ language
- they act much like sentences do in natural language
- Most end in a semicolon (;)
- ![Pasted image 20230718204415.png](/img/user/_Archivos/Pasted%20image%2020230718204415.png)

# IDEs, Instalación, Compiladores

- Aspectos básicos:
	- Es necesario compilar el codigo fuente en codigo maquina
	- g++ es el compilador, lo convierte en un fichero ejecutable.
	- Diferencias: python mas lento pero facil de escribir. C++ permite hacer operaciones de bajo nivel, es más eficiente (espacio y tiempo), código preciso para ciertas acciones.
		- Python te ahorraba tener que indicar el tipo de variable.
	- En qué convierte el compilador un codigo fuente?
		- En archivos de objeto llamados tipicamente *nombre.o* o nombre.obj.
		- En binario, leíble por la compu

- **INSTALACIÓN**
	- [C++ programming with Visual Studio Code](https://code.visualstudio.com/docs/languages/cpp#_example-install-mingwx64)
	- [MSYS2](https://www.msys2.org/)
	- setup correctly (linux too): https://www.learncpp.com/cpp-tutorial/installing-an-integrated-development-environment-ide/)
	- Programs that are easily portable to LInux: https://www.codeblocks.org/downloads/binaries/

- **CONFIGURAR COMPILADOR**
	- https://www.learncpp.com/cpp-tutorial/configuring-your-compiler-build-configurations/

- **FORMAS DE COMPILAR**;
	- 1)  Directamente en exe
		- ``g++ principal.cpp auxiliar.cpp -o programa.exe``
	- 2)  Primero objetos, luego linkeado en exe
		- ``g++ -c auxiliar.cpp``
		- ``g++ -c principal.cpp``
		- `g++ principal.o auxiliar.o -o programa.exe` (enlace)
	- La ventaja del 2 es que obtenemos los.o y ante cambios no habrá que recompilarlo todo

# Includes, Namespaces

[Headers and Includes: Why and How - C++ Articles](https://cplusplus.com/articles/Gw6AC542/)

- **HPP (HEADER FILES)**
	- Archivos que contienen las declaraciones de las funciones y clases.
	- Se deben incluir en todos los archivos que se vayan a compilar
	- The **.h** file declares code, and the **.cpp** file implements that declaration
	- tienen extension.h o.hpp.
	- No se compilan, se incluyen en los módulos usados. Al contrario que.cpp

- *LINKER*
	- Takes all the object files generated by the compiler and {; combines} them into a single executable program.

- *g++ hace*:
	- preproceso (includes), la compilacion, enlazado (genera el ejecutable y junta los compilados).
	- ![2023-09-14_14-07-07_pre_comp_link.png](/img/user/_Archivos/2023-09-14_14-07-07_pre_comp_link.png)

- ``#include <headerfile>``
	- Include es una directiva, se sustituye con los contenidos del archivo incluido.
	- se puede separar el código en varios archivos. Se detecta y se compila todo junto.
	- Usar ``#include <iostream>`` para agregar objetos de entrada y salida. (cin, cout)

- **Header guards: IFNDEF Y DEFINE**
	- Son directivas que se usan para evitar incluir varias veces el mismo archivo header.
	- *Todos los headers deben tenerlos*.
	- ``#ifndef NAME`` Mira si un identificador {; no está incluido}, entonces, el codigo hasta ``#endif`` será compilado
	- ``#define NAME`` Marca el header como incluido.

- espacio de Nombres
	- Escribir las funciones del.hpp file dentro de un bloque como "namespace misfunciones" ayuda a que las funciones definidas dentro de él no sean confundidas con funciones con el mismo nombre de fuera de él.
	- Para crear o usar las funciones ahora deberemos acceder a ellas mediante misfunciones::funcion

	- Obviamente dentro de un namespace todas las funciones deben tener distinto nombre

	- Un ejemplo de espacio de nombres es std, usado en cout, string...
	- *using namespace std*  -> nos permite acceder a lo de std sin mencionarilo con su prefijo, puede causar conflictos

# Git

- No está bien explicado desde 0, esto son simplemente los pasos más comunes

- Pasos clave cada vez que se quiere subir algo nuevo a un directorio ya existente:
	``git add.``
	``git commit -m "TEXTO"``
	``git push``

- Agregar repositorio
	``git clone "url_repositorio"``

- Configuraciones:
	``git config--global...``

# Variables + Types of Data

- **INSTANTIATION**

	- A variable is a named *object*
	- Variables are used to access memory.
	- Variables have an *identifier* (name), a *type*, and a *value*
{ #73bxc6}

	- the variable will be *instantiated* when the program is run (called runtime)
			- Instantiation means the object will be created and assigned a memory address

	```cpp
	// VARIABLE INITIALIZATION
	int x; // define a variable named x, of type int
	int a, b;  // define multiple variables 
	int a; double b; // correct (but not recommended)
	```

	```cpp
	// WRONG:
	int a, int b;
	int a, double b;
	```

	- *List initialization* produces an error when initializing a variable with a wrong type (useful)

	```cpp
	// VARIABLE ASSIGMENT AND INITIALIZATION
	
	int width; // define an integer variable named width
	width = 5; // copy assignment of value 5 into variable width
	
	int b = 5;     // initializer after equals sign (copy initialization)
	
	int c( 6 );    // initializer in parenthesis (direct initialization)
	
	// List initialization methods (C++11) (preferred)
	int d { 7 };   // initializer in braces (direct list initialization)
	int e = { 8 }; // initializer in braces after equals sign (copy list initialization)
	int f {};      // initializer is empty braces (value initialization)
	```

	- *Initialization* gives a variable an initial value at the point when it is created.
	- *Assignment* gives a variable a value at some point after the variable is created

	- *Default initialization* is when a variable initialization has no initializer (e.g. `int x;`). In most cases, the variable is left with an indeterminate value.
	- *Value initialization* is when a variable initialization has an empty brace (e.g. `int x{};`). In most cases this will perform zero-initialization.
	- *You should prefer value initialization* to default initialization

	```cpp
	// MULTIPLE INITIALIZATION
	int a = 5, b = 6;          // copy initialization
	int c( 7 ), d( 8 );        // direct initialization
	int e { 9 }, f { 10 };     // direct brace initialization (preferred)
	int g = { 9 }, h = { 10 }; // copy brace initialization
	int i {}, j {};            // value initialization
	
	// WRONG
	int a, b = 5; // wrong (a is not initialized!)
	int a, b( 5 );
	```

	*Value Initialization and Zero Initialization { 0 } Vs {}*

	Use an explicit initialization value if you’re actually using that value.

	```cpp
	int x { 0 };    // explicit initialization to value 0
	std::cout << x; // we're using that zero value
	```

	Use value initialization if the value is temporary and will be replaced.

	```cpp
	int x {};      // value initialization
	std::cin >> x; // we're immediately replacing that value
	```

- **TYPES OF DATA**

	- A data type (more commonly just called a type) tells the compiler what type of value (e.g. a number, a letter, text, etc…) the variable will store.
	- C++ also allows you to *create your own* user-defined types

	- ![2023-09-16_12-09-37_datatypes.png](/img/user/_Archivos/2023-09-16_12-09-37_datatypes.png)
	- char: Surround with single quotes
	- *==String==*:
		- Text, double quotes
		- Use import ``<string>`` library
		- Can use + to concatenate. Or *append()* function
		- Can access or modify certain characters using string[n] (python)  or *string[n] = 'm'*
		- auto: automatically detect the type of variable
	- null pointer
	- void: no storage, absence of value (None in python)
	- ==const==: read-only

- **Creating variables**

	```cpp
	int x = 5;
	int y(3);
	int z{2};
	float pi = 3.1416;
	float cash = 2;
	char a = 'a';
	bool is_true = true;
	auto check = false;
	
	```

# Operadores, Logicos, Operaciones...

- Igual que python
- Orden: Parenthesis first, then Exponents, then Multiplication & Division, then Addition & Subtraction
- ==++ y --: Increment, decrement==
- ==+=: Add a value to a variable==

```cpp	
cout << 5 + 2 << endl; // 7
```

**Logical Operators**

![2023-09-16_12-18-16_logical.png](/img/user/_Archivos/2023-09-16_12-18-16_logical.png)

![2023-09-16_12-19-07_and_or_not.png](/img/user/_Archivos/2023-09-16_12-19-07_and_or_not.png)

```cpp
cout << (5 == 5) << endl; // 1 
string y;
getline(cin, y);
return 0;
```

# Estructuras De Datos

- VECTORES

	- *OPERACIONES BÁSICAS*

		- Needs: `#include <vector>`
		- *Create*
			- ``std::vector<int> v;``  (vacio)
			- ``std::vector<int> v2 = { 2, 3, 5, 7 }``
		- *Access* elements
			- ``v[0]``
				- Careful, because the compiler won't detect if index is incorrect
			- ``v.at(1)``  hace la comprobación de sí el indice está dentro de los limites, genera una excepción si no lo está (usar try-catch)
		- Vector containing x elements with y value
			- ``std::vector<int> data(10);``  (default value: 0)
			- ``std::vector<int> vector3(5, 12);`` (5 elements with value 12)
		- Constant vector
			- ``const std::vector<int> prime { 2, 3, 5, 7, 11 };``
			- Not allowed: ``std::vector<const int> prime { 2, 3, 5, 7, 11 };``  (elements of a non-const vector must be non-const)
		- *Add* elements
			- ``v.push_back(6)``
		- *Delete last* element
			- ``v.pop_back()``
		- *Tamaño* (cantidad elementos)
			- `v.size()`
		- *Recorrer vector*
			- `for (int i = 0; i < v.size(); ++i)`
		- *Ordenar vector*
		- Other functions
			- clear()
			- front()     returns first element
			- back()      last element
			- empty()   boolean
			- capacity()   overall size
		- *Passing parameters by reference and keep it constant*
			- `(const std::vector<int>& v)`
		- Copying an array (independent)
			- `std::vector arr2 { arr1 };`

	- *Reserva de memoria*
		- Interesante si conoces cuantos contendrá
		- `miVector.reserve(100);`

- [CADENAS](https://cplusplus.com/reference/string/string/)

	- Concatenar
		- `std::string result = str1 + str2;`
	- *Convertir número a string*
		- `std::string str = std::to_string(number);`
	- Longitud
		- ``cadena.length()`` o ``cadena.size()``
	- Acceso a elementos o modificar
		- ``c[1]="a"``
			- Esto en python no se puede, pero aquí sí

- MAPS (diccionarios)

	```cpp
	#include <iostream>
	#include <map>
	#include <string>
	#include <utility>  // Para usar make_pair
	
	// Las claves deben ser únicas
	// Se almacenan ordenados por clave
	
	
	int main() {
	    // 1. Creating a Map
	    std::map<int, std::string> studentMap;
		std::map<const int, int> mapaClave    // Clave invariable
		std::map<int, string> student = { {1,"Jacqueline"}, {2,"Blake"}, {3,"Denise"}}
	
	    // 2. Inserting Key-Value Pairs
	    studentMap[101] = "Alice";
	    studentMap[102] = "Bob";
	    studentMap[103] = "Charlie";
	    studentMap.insert(std::make_pair(104, "Juan"))
	
	    // 3. Accessing Values by Key
	    int studentID = 102;
	    std::string studentName = studentMap[studentID];
	    std::cout << "3. Accessing by Key: Student " << studentID << ": " << studentName << std::endl;
	
	    // 4. Checking if a Key Exists
	    int searchID = 104;
	    if (studentMap.find(searchID) != studentMap.end()) {
	        std::cout << "4. Key " << searchID << " exists." << std::endl;
	    } else {
	        std::cout << "4. Key " << searchID << " does not exist." << std::endl;
	    }
	
	    // 5. Iterating Through the Map
	    std::cout << "5. Iterating Through the Map:" << std::endl;
	    for (std::pair <const int, string> item : studentMap) {
	        std::cout << "   Student " << item.first << ": " << item.second << std::endl;
	    }
		    // Con esto se crea un mapa a partir del diccionario, podemos modificar los valores del mapa, pero no el diccionario como tal
	
	    // 6. Removing a Key-Value Pair
	    int removeID = 101;
	    studentMap.erase(removeID);
	    std::cout << "6. Removing a Key-Value Pair: Student " << removeID << " removed." << std::endl;
	
	    // 7. Checking the Size of the Map
	    size_t mapSize = studentMap.size();
	    std::cout << "7. Size of the Map: " << mapSize << " students remaining." << std::endl;
	
	    return 0;
	}
	```

- Conjuntos (sets)

	```cpp
	#include <iostream>
	#include <set>        // Importante
	using namespace std;
	
	int main() {
	    // Create a set
	    std::set<int> mySet;
	
	    // Insert elements
	    mySet.insert(5);
	    mySet.insert(3);
	    // If an element is already added, it will be ignored.
	    mySet.insert(5);
	
	    // Print the set
	    cout << "The elements of the set are: ";
	    for (auto it = mySet.begin(); it != mySet.end(); ++it) {
	        cout << *it << " ";
	    }
	    cout << endl;
	
	    // Erase an element
	    mySet.erase(3);
	
	    // Print the set after erasing
	    cout << "The elements of the set after erasing 3 are: ";
	    for (auto it = mySet.begin(); it != mySet.end(); ++it) {
	        cout << *it << " ";
	    }
	    cout << endl;
	
	    // Check if the set is empty
	    if (mySet.empty()) {
	        cout << "The set is empty." << endl;
	    } else {
	        cout << "The set is not empty." << endl;
	    }
	
	    // Get the size of the set
	    cout << "The size of the set is: " << mySet.size() << endl;
	
	    // Find an element in the set
	    auto search = mySet.find(2);
	    if (search != mySet.end()) {
	        cout << "Found " << *search << '\n';
	    } else {
	        cout << "Not found\n";
	    }
	
	    // Clear the set
	    mySet.clear();
	    
	    return 0;
	}
	```

# Control Flow: If, While, For, Break

[4.10 -- Introduction to if statements](https://www.learncpp.com/cpp-tutorial/introduction-to-if-statements/) y [Control flow introduction](https://www.learncpp.com/cpp-tutorial/control-flow-introduction/)

## Break, Return, Continue

- break: jump out of loop
- Continue: Going to the next iteration

## If, Else If, Else

- Ejemplo

```cpp
if (x > y)
	std::cout << "Una instrucción puede ponerse sin {}";
else if (x == y)
{
	// etc
}
else
{ // note addition of block here
	std::cout << "You are not tall enough to ride.\n";
	std::cout << "Too bad!\n";
}

if (x > 10)
    ; // this is a null statement
```

## Switch

- Bloques if-else muy optimizados
- Condición debe ser un numero unico
- El default se ejecuta si ninguno coincide
- Es importante usar break o return
```cpp
switch (x) // x is evaluated
	{
		case 1:
			std::cout << "One";
			return;
		case 2:
			std::cout << "Two";
			return;
		case 3:
			std::cout << "Three";
			break;
		default:
			std::cout << "Unknown";
			break;
	}
```

==MIRAR MÁS==: [8.6 — Switch fallthrough and scoping – Learn C++](https://www.learncpp.com/cpp-tutorial/switch-fallthrough-and-scoping/)

## Goto

- Used for jumping to a labeled statement in the same function.
- Avoid using it as much as possible (use for, while, do-while)
```c++
#include <iostream>

int main() {
    int x = 0;

    start: // Label
    x++;

    if (x < 5) {
        goto start; // Jump back to the label
    }

    std::cout << "x is " << x << std::endl;

    return 0;
}

```

## For

- The end-expression is evaluated the last in the loop
``` c++
for (init-statement; condition; end-expression)
   {
   statements;
   }
```
- For loops with multiple counter
```c++
#include <iostream>

int main()
{
    for (int x{ 0 }, y{ 9 };    x < 10;    ++x, --y)
        std::cout << x << ' ' << y << '\n';
    return 0;
}
```
- Loop through elements in a list:
```c++
int myNumbers[5] = {10, 20, 30, 40, 50};  
for (int i : myNumbers) {  
  cout << i << "\n";  
}
```

## While

- You can exit infinite loops with return, break, exit, goto
``` c++
#include <iostream>

int main() 
{
    int x = 0;
    // Mientras x menor que 5, sumar 1 a x:
    while (x < 5) {
        x++;
    }
    std::cout << "x is " << x << std::endl;
    return 0;
}
```

## Do-while

- *Executes the code block once before checking conditions*
- Effective for reducing complexity
- Use it as less as possible.
- For showing a menu for example and then asking repeatedly for a number

```c++
#include <iostream>

int main()
{
    // selection must be declared outside of the do-while-loop
    int selection{};

    do
    {
        std::cout << "Please make a selection: \n";
        std::cout << "1) Addition\n";
        std::cout << "2) Subtraction\n";
        std::cin >> selection;
    }
    while (selection != 1 && selection != 2);
}
```

# Entrada y Salida, Ficheros

- **STRING**

	```cpp
	#include <iostream>
	#include <string>
	
	int main() {
	    // 1. Creating and Initializing Strings
	    std::string str1 = "Hello, ";
	    std::string str2 = "world!";
	    
	    // 2. Concatenating Strings
	    std::string greeting = str1 + str2;
	    std::cout << "1. Concatenating Strings: " << greeting << std::endl;
	
	    // 3. String Length
	    std::string text = "This is a sample text.";
	    int length = text.length();
	    std::cout << "2. String Length: " << length << " characters." << std::endl;
	
	    // 4. Accessing Characters
	    char firstChar = text[0];
	    char lastChar = text[length - 1];
	    std::cout << "3. Accessing Characters: First: " << firstChar << ", Last: " << lastChar << std::endl;
	
	    // 5. Substring
	    std::string substring = text.substr(5, 6); // Starting from index 5, take 6 characters
	    std::cout << "4. Substring: " << substring << std::endl;
	
	    // 6. Find and Replace
	    std::string sentence = "Replace the word 'world' with 'universe' in this sentence.";
	    std::string target = "world";
	    std::string replacement = "universe";
	    size_t found = sentence.find(target);
	    if (found != std::string::npos) {
	        sentence.replace(found, target.length(), replacement);
	    }
	    std::cout << "5. Find and Replace: " << sentence << std::endl;
	
	    // 7. Compare Strings
	    std::string str3 = "apple";
	    std::string str4 = "banana";
	    int comparisonResult = str3.compare(str4);
	    if (comparisonResult < 0) {
	        std::cout << "6. Compare Strings: " << str3 << " comes before " << str4 << std::endl;
	    } else if (comparisonResult > 0) {
	        std::cout << "6. Compare Strings: " << str3 << " comes after " << str4 << std::endl;
	    } else {
	        std::cout << "6. Compare Strings: " << str3 << " is equal to " << str4 << std::endl;
	    }
	
	    return 0;
	}
	```

- **STD::COUT, CIN, ENDL, GETLINE**

	```cpp
	#include <iostream>
	#include <string>
	
	int main() {
	    // 1. Output using std::cout
	    int x = 42;
	    std::cout << "1. Output using std::cout: x is equal to: " << x << std::endl;
	
	    // 2. Output with std::endl
	    std::cout << "2. Output with std::endl: Hi!" << std::endl;
	
	    // 3. Input using std::cin
	    int y;
	    std::cout << "3. Input using std::cin: Enter a value for y: ";
	    std::cin >> y;
	    std::cout << "You entered: " << y << std::endl;
	
	    // 4. Input of multiple data in a single line
	    double a, b;
	    std::cout << "4. Input of multiple data in a single line: Enter values for a and b: ";
	    std::cin >> a >> b;
	    std::cout << "You entered a = " << a << " and b = " << b << std::endl;
	
	    ///// 5. Get entire lines as input
	    std::string linea;
	    std::cout << "5. Get entire lines as input: Enter a sentence: ";
	    std::cin.ignore(); // Clear the newline character left in the input buffer
	    std::getline(std::cin, linea);
	    std::cout << "You entered: " << linea << std::endl;
	
	    return 0;
	}
	``` 
	^x8aec2

- **stringstream**

	```cpp
	#include <iostream>
	#include <sstream>  // Importante
	#include <string>
	
	int main() {
	    // Creating a stringstream
	    std::stringstream ss;
	    std::ostringstream oss;
	    std::istringstream iss;
	    std::istringstream ss(text);
	    
	
	    // 1. Basic Usage: Converting Data Types to Strings
	    int num = 42;
	    double pi = 3.14159265359;
	    ss << "Integer: " << num << ", Double: " << pi;
	    std::string result = ss.str();
	    std::cout << "1. Basic Usage: " << result << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 2. Parsing Strings into Data Types
	    std::string data = "123 45.6789";
	    int parsedInt;
	    double parsedDouble;
	    ss.str(data); // Load data into stringstream
	    ss >> parsedInt >> parsedDouble;
	    std::cout << "2. Parsing Strings: Integer: " << parsedInt << ", Double: " << parsedDouble << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 3. Appending to an Existing String
	    ss << "Hello, ";
	    std::string name = "Alice";
	    ss << name << "!";
	    std::string greeting = ss.str();
	    std::cout << "3. Appending to String: " << greeting << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	
		// 4. BUCLES LECTURA DE LINEAS
		std::istringstream flujo_linea(linea);
		while (flujo_linea >> n) {
			// Do something
			// Esto agrega cada "palabra" individual a n, mientras haya
		}
	
	    // 4. Formatting Output
	    double value = 1234.5678;
	    ss << "Value: " << std::fixed << std::setprecision(2) << value;
	    std::string formattedValue = ss.str();
	    std::cout << "4. Formatting Output: " << formattedValue << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 5. Extracting a Substring
	    std::string longText = "This is a long sentence.";
	    ss.str(longText);
	    std::string subString;
	    ss >> subString;
	    std::cout << "5. Extracting Substring: " << subString << std::endl;
	
	    return 0;
	}
	```

- **Ficheros**

	```cpp
	#include <iostream>
	#include <fstream>   // Importante
	#include <string>
	
	int main() {
	    // Create a file object for output
	    std::ofstream outFile("output.txt");
	
	    // Check if the file opened successfully
	    if (outFile) {
	        // Write data to the file
	        outFile << "Hello, Files!" << std::endl;
	
	        // Close the file
	        outFile.close();
	    } else {
	        std::cerr << "Error opening the file." << std::endl;
	    }
	
	    // Create a file object for input
	    std::ifstream inFile("input.txt");
	
	    // Check if the file opened successfully
	    if (inFile) {
	        std::string line;
	        // Read the file line by line
	        while (std::getline(inFile, line)) {
	            if (!line.empty()) {
	                std::cout << "Line: " << line << std::endl;
	            }
	        }
	
	        // Close the file
	        inFile.close();
	    } else {
	        std::cerr << "Error opening the file." << std::endl;
	    }
	
	    return 0;
	}
	
	```

- **NAN**

	```cpp
	#include <iostream>
	#include <cmath>   // importante
	
	int main() {
	    // Create a NAN value
	    double nanValue = std::nan("");
	
	    // Check if a value is NAN
	    if (std::isnan(nanValue)) {
	        std::cout << "The value is NAN." << std::endl;
	    } else {
	        std::cout << "The value is not NAN." << std::endl;
	    }
	    return 0;
	}
	```

- **SETW**, LEFT AND RIGHT

	`#include <iomanip>`
	`outFile << std::setw(10) << "Name" << std::setw(10) << std::endl;`

	- Lo que hace es indicar que la columna ocupara X caracteres, alinea el texto a la derecha

	*seek* (no lo hemos dado)

	- [28.7 — Random file I/O – Learn C++](https://www.learncpp.com/cpp-tutorial/random-file-io/)

# Técnicas de caja negra y blanca

- Si el programa de pruebas está mal, es que la tabla de casos y escenarios deben ser corregidas.

- CPPUNIT

	- Clase y programa en un fichero
	- Agrupar pruebas en clase TestFixture con TestSuite
	- No es necesario usar un método de prueba distinto para cada caso de prueba si hay muchos.
	- Lanzador con salida por consola
	- `g++ AAA_test.o AAA.o -lcppunit -o AAA_test`

- OBJETIVOS
	- Pruebas de Unidad: Funciones o clases
	- Un programador debe evitar probar su propio programa
	- Prever condiciones inválidas
	- Evita improvisar los casos de prueba
	- El estado mental correcto es asumir que habrá errores.

	- Técnica FIRST:
		- Fast (rápido): Ejecución frecuente de los tests
		- Independent (independiente): El orden de los tests no debe de afectar al resultado
		- Repeatable (repetible): Independiente del servidor, configuración...
		- Self-validating (auto evaluable): Booleano como resultado, no debemos comprobar el resultado de los tests de forma manual.
		- Timely (oportuno): Hacer las pruebas antes de desarrollar el programa

- **TÉCNICAS DE CAJA NEGRA**

	- Comprobar el comportamiento sin conocer su implementación interna (Resultados externos)
	- Sirven para definir un conjunto de ESCENARIOS

	```cpp
	 1    int f(int a, int b) {
	 2        if (a > 10) {            // D1
	 3            a += 10;
	 4        }
	 
	 5        if (a > 2 and b > 2) {   // D2 (D2.1 y D2.2)
	 6            return a * b;
	 7        } else {
	 8            return a + b;
	 9        }
	10    }
	```

	- **TABLA DE ESCENARIOS**

		- Situaciones generales donde queremos probar el programa.
		- Un escenario es inválido si no se cumplen las precondiciones.
		- Los escenarios pueden estar en funcion de 1 entrada, relaciones de varias entrada, o de salida.
		- No todo escenario va a acabar convirtiéndose en una prueba específica.

		- Posibles escenarios:
			- Equilatero, Isosceles, Escaleno, No es un triangulo
			- La decisión del if de la línea 10 del método llega a tomar el valor false

		- *Planteamiento de escenarios*
			- escenarios basados en las entradas
				- En números, negativos, 0, positivos
			- escenarios basados en las relaciones entre las diferentes entradas
				- a > b+c
			- escenarios basados en las posibles salidas
			- escenarios basados en la relación entre entradas y salidas

		- *Escenarios inválidos vs válidos*
			- Cada escenario inválido ha de ser cubierto con un caso de prueba específico que no cubra ningún otro escenario inválido
			- En escenarios válidos, cubrir cuantos más mejor

		- Prefijos
			- V o I según valido o invalido

		- TABLA ESCENARIOS EJEMPLO
			- ![2023-10-13_16-12-00_escenarios_tabla.png](/img/user/_Archivos/2023-10-13_16-12-00_escenarios_tabla.png)

	- **TABLA DE CASOS**
		- ![2023-10-13_16-02-46_casosprueba.png](/img/user/_Archivos/2023-10-13_16-02-46_casosprueba.png)
		- Casos concretos (*completamente especificados*) usados para comprobar el programa.
			- a = 7,    b = 8,    salida true
		- Con pocos casos de prueba cubrimos muchos escenarios.
		- Se puede dividir la entrada en subcolumnas





- **TÉCNICAS DE CAJA BLANCA**

	- DEFINICIÓN Y CONCEPTOS
		- A diferencia de la caja negra, aquí nos dejamos guiar por el código que queremos probar. Prueban la estructura interna y la lógica de un código, sabiendo como funciona por dentro.
		- No tenemos en cuenta codigos validos o invalidos, simplemente queremos probar todo el codigo.
		- Deberemos hacer *diferentes casos de prueba para que se cubran todas las posibles coberturas*

	- POSIBLES COBERTURAS:      `c1 or (c2 and c3)`
		- Cobertura de sentencias
			- Todas cubiertas al menos una vez
			- Ejemplo, un if sin else, o se cubre la sentencia o no se cubre
		- Escenarios de cobertura de *decisiones*
			- (un test que cubra ejemplos para todos los "if" por ejemplo *al menos una vez con true y false*)
			- Ignoramos la complejidad y los operadores lógicos, solo nos importa true o false.
			- D1T, D2F
		- Cobertura de *condiciones*
			- Son los elementos más pequeños, unidos con "or", "and"...
			- D1.1F, D1.2T, D1.3T, D1.3F...
			- C1T, C1F, C2T, C2F, C3T, C3F
			- 2^n escenarios para n condiciones
		- Cobertura de *condición múltiple*
			- Tablas de verdad para cada decisión.
			- D1TXX, D1FTT, D1FTF, D1FFX
			- C++ es en *circuito corto*, por lo que a veces es inutil seguir comprobando si ya se cumple.



	- *CAJA BLANCA EJEMPLO*:
		```cpp
		int CountNumbers(const std::string& s) {
		    int n = 0;
		    bool out_before = true;
		    for (int i = 0; i < s.length(); ++i) {
		        if (s.at(i) >= '0' and s[i] <= '9') { // now in a number
		            if (out_before) {
		                ++n;
		                out_before = false;
		            }
		        } else {
		            out_before = true;
		        }
		    }
		    return n;
		}
		```


		- **TABLA DE DECISIONES**
			![2023-10-27_20-20-11_.png|409](/img/user/_Archivos/2023-10-27_20-20-11_.png)
			- Error: `1 < s.length()` es` i < s.length()`
			- *Decisión*: todo lo de dentro de un if
			- *Escenarios*: (T/F) para cada decisión
			- Al hablar de un escenario concreto (Como D1F) queremos decir las situaciones en las que al ejecutar el programa se cumplirá ese escenario concreto al menos una vez. D1F -> siempre, indica que en la ejecución del programa, independentemente de cadena introducida, siempre se llegará a cumplir. En este programa se debe a que el bucle for va decrementando la i (la foto está mal es una i en lugar de 1)

		- **TABLA DE CASOS**
			![2023-10-27_20-19-01_.png|380](/img/user/_Archivos/2023-10-27_20-19-01_.png)
			- Con un solo caso cubrimos los 6 escenarios. Con esto queremos decir que al ejecutar el programa con el input "x44y9", se pasará por todos los tipos escenarios posibles para las diferentes sentencias if, while... Comprobando así la seguridad del código al no dejar nada por revisar.


		- **TABLA DE ESCENARIOS ---- COBERTURA DE CONDICIÓN MULTIPLE**
			![2023-10-27_20-18-16_.png|557](/img/user/_Archivos/2023-10-27_20-18-16_.png)
			- Todo lo de la tabla de decisiones anterior, pero ahora viendo cada *condición* concreta por separado.
			- *Decisiones iguales en diferentes puntos* han de ser tratadas (x>10)

		- **TABLA DE CASOS  -----  COBERTURA DE CONDICIÓN MULTIPLE**
			![2023-10-27_20-18-43_.png](/img/user/_Archivos/2023-10-27_20-18-43_.png)
			- Igual que la normal pero ahora según los nuevos escenarios, más posibilidades
			- Datos:
				- / esta por debajo del 0
				- : esta por encima del 9

# Excepciones

- BLOQUES TRY/CATCH

	```c++
	try {
	    // Código que podría lanzar una excepción
	} catch (const std::runtime_error& e) {
	    // Manejar excepción de std::runtime_error
	} catch (const std::exception& e) {
	    // Manejar excepción genérica de std::exception
	}
	
	```

- LANZAR
	- `throw std::invalid_argument("elements is empty");`

- UNITTEST
	- `CPPUNIT_ASSERT_THROW(funcion(), std::invalid_argument)`

# Programación Orientada a Objetos

[[0-Inbox/OOP, Programación Orientada a Objetos\|OOP, Programación Orientada a Objetos]]

# Punteros y memoria dinámica

- ARRAYS DE C Y PUNTEROS / MEMORIA DINÁMICA
	- `int foo [20];`    // Talla fija de tipo int
	- `int* foo = new int[5];`
		- Returns a pointer to the first element.
		- The first element can be accessed with `foo[0]` or  `*foo`
		- The second, with `foo[1]` or `*(foo+1)`

- `delete[] pointer;`
	- releases the memory allocated for arrays of elements using new and a size

```cpp  file:"Ejemplo Aritmétrica Punteros" hl:9
char *mychar;    // Memoria 1000
short *myshort;  // Memoria 2000
long *mylong;    // Memoria 3000

++mychar;    // +1
++myshort;   // +2
++mylong;    // +4

// Esto se debe a que sumar uno a un puntero se hace segun el tamaño del tipo de dato que contiene cada puntero. No tendría sentido sumar siempre 1 a la dirección de memoria.

// También se puede usar --
// También se pueden usar otros números a sumar o restar



*p++   // same as *(p++): increment pointer, and dereference unincremented address
*++p   // same as *(++p): increment pointer, and dereference incremented address
++*p   // same as ++(*p): dereference pointer, and increment the value it points to
(*p)++ // dereference pointer, and post-increment the value it points to 
```

- **copy and swap**
	- en c++, al hacer a=b, esperamos que `a` y `b` sigan vidas independientes
	- intercambia el contenido de dos objetos sin necesidad de copiar sus datos
	```cpp warn:2
	ListaSimple& ListaSimple::operator=(const ListaSimple& otra) {
		if (&otra != this) {
			//(this != &otra): Si hacen referencia exactamente al mismo objeto, en la misma posición de memoria, simplemente devolverlo

			// - Esto evita autoasignación, como vector1 = vector1, cosa que daría error al borrar los datos y luego intentar acceder a ellos.

			// - Lo que no evita es hacer vector1 = vector2, vector1 = vector2, vector1 = vector2...
			ListaSimple copia(otra);
			std::swap(ini_, copia.ini_);
			std::swap(fin_, copia.fin_);
			std::swap(talla_, copia.talla_);
			// ahora el objeto actual (`*this`) contiene los datos de la copia,
			// y la copia contiene los datos originales del objeto actual
		}
	// Al salir del if, se destruye automatico el objeto copia
	// con los contenidos del antiguo this
	return *this;
	}
	```

# Costes

- COSTE PEOR CASO
- COSTE AMORTIZADO
	- Es simplemente el coste medio.
	- Consiste en encontrar la operación más costosa y la menos costosa, y encontrar el punto medio para regularlo.
	- Esto tiene que ver con la práctica 9 de vectores, donde el peor caso para agregar un elemento era de 1, hasta que el array se tenía que duplicar, agregando todos los elementos, y luego agregar el nuevo, siendo un coste de n.
	- BOLETIN
		- es de 2\*(i-2)         el coste acumulado en los peores moomentos, donde se duplica el espaio
		- 3n -4      lineal
		- *si siempre amplias mediante una cosntante, el coste total sale cuadratico, el coste amortizado sale lineal*

- **ESQUEMAS ALGORITMICOS**        (examen practico)
	- busqueda anchura
	- divide y vencerás          (examen hasta aqui)

- algoritmos sobre grafos
	- muchos problemas son adaptar los algoritmos del recorrido sobre grafos
	- GRAFO: conjunto de vértices y aristas
	- Dado un grafo, se quiere hacer cierta tarea, recorrido...

	- Recorrido en anchura      (ejemplo algoritmo)
		- miramos cada nodo y sus vecinos, ponemos en la cola los que no hemos visto y tambien lo ponemos en vistos, luego vamos viendo todos los vecinos etc.

# Cuestiones Random

- **ONE LINE CONDITIONS**:
	- `condition? value_if_true: value_if_false`
	- `std::cout << (veces > 1? " veces": " vez")`
		- Se imprime " veces" si la variable es mayor que 1, y " vez" si no.

- POST / PRE-INCREMENTO
	```cpp
	// PRE-INCREMENTO, antes de evaluar la expresión
	int a = 5;
	int b = ++a; // Ahora, a=6 y b=6
	// POST-INCREMENTO, después de evaluar la expresión
	int a = 5;
	int b = a++; // Ahora, a=6 y b=5
	```

- **Variables locales:**
	- Si se crean dentro de un bloque if/else por ej. solo se pueden acceder desde dentro de él

- **Pasar por referencia**
	- ``int &refNumero = numero;``  // refNumero es una referencia a numero
	- Recibiremos por **referencia `const`** todas las estructuras de datos que sean parámetros de una función (vectores, *strings*, conjuntos, diccionarios...) y no sea un objetivo específico de esa función modificar.

	```cpp
	int numero = 30;
	int &refNumero = numero;  // refNumero es una referencia a numero
	
	refNumero = 40;  // Modificar refNumero también modifica numero
	```


- **EXPRESIONES PELIGROSAS** (vectores):
	`v.size()-1`
	- PROBLEMA: Si `v` está vacío, `v.size()` vale cero y, además, es de un tipo entero sin signo, de tal forma que `0-1` en un tipo así puede dar un resultado grandísimo
	- SOLUCION: asignar `v.size()` a una variable de tipo `int` antes de restarle nada. Si la resta se hace sobre esa variable, un posible resultado negativo se calculará con completa normalidad
		```cpp  
		int i = v.size();
		--i;
		```

	`v[i]`
	- PROBLEMA: Comportamiento indefinido cuando i está fuera del rango válido
	- SOLUCION: Sustituir los accesos `v[i]` por accesos `v.at(i)`
	```cpp  
	while (not v.empty and v[i] == 0) {
	    v.pop_back();
	    --i;
	// C++ es de circuito corto: Si el 1r operando de un and es false, no se evalua el 2o.
	}
	```

- En c++ haremos *copias* al usar el =, a diferencia de python que es una asignación (en listas por ej.)

- Diferencia entre *constructores copia, y asignaciones*
	- COPIA
		- int a = 3, b = 4;
		- int a(3), b(4);
		- int a{3}, b{4};
	- ASIGNACION
		- int a{};
		- a = 3;

- `if (izq)` =  `if (izq!= nullptr)`
	- Siendo izq un puntero.
