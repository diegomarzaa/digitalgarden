---
{"dg-publish":true,"permalink":"/1-Referencias/Teoría Programación Avanzada - C++/","title":"Teoría Programación Avanzada - C++","noteIcon":""}
---


> [!info]+ Información
> Nota con cosas extra algo más desordenadas que no hemos dado como tal en la carrera: [[1-Referencias/Conceptos Adicionales C++\|Conceptos Adicionales C++]]

> [!warning]+ Aviso
> Muchas veces se pueden asumir conocimientos básicos de otros lenguajes de programación, como python.

# Introduction

C++ es un lenguaje de programación de alto nivel que se utiliza para desarrollar aplicaciones de software. Es una extensión del lenguaje de programación C y agrega características como la programación orientada a objetos y la manipulación de memoria. C++ es ampliamente utilizado en la industria del software debido a su eficiencia y capacidad para crear programas de alto rendimiento.

Four major updates to the C++ language (C++11, C++14, C++17, and C++20)
- C++11 is typically considered the modern minimum
- Finalized language standards are named after the years in which they are finalized (e.g. C++17 was finalized in 2017).

"Trust the programmer":
C++ is designed to allow the programmer a high degree of freedom to do what they want. However, this also means the language often won’t stop you from doing things that don’t make sense, because it will assume you’re doing so for some reason it doesn’t understand.

**Puntos Positivos C++**

- excels in situations where high performance and precise control over memory and other resources is needed

**Good Practise**

When you sit down and start coding right away, you’re typically thinking “I want to do something”, so you implement the solution that gets you there the fastest. This can lead to *programs that are fragile*, hard to change or extend later, or have lots of bugs (technical defects).
*it’s worth your time to spend a little extra time up front* (before you start coding) thinking about the best way to tackle a problem, what assumptions you are making, and how you might plan for the future, in order to save yourself a lot of time and trouble down the road.


**STATEMENTS**
- they are the smallest independent unit of computation in the C++ language
- they act much like sentences do in natural language
- Most end in a semicolon (;)
- ![Pasted image 20230718204415.png](/img/user/_Archivos/Pasted%20image%2020230718204415.png)

# [[0-Inbox/Compilación en C++\|Compilación en C++]]

# Includes, Namespaces

[Headers and Includes: Why and How - C++ Articles](https://cplusplus.com/articles/Gw6AC542/)

- **HPP (HEADER FILES)**
	- Archivos que contienen las declaraciones de las funciones y clases.
	- Se deben incluir en todos los archivos que se vayan a compilar
	- The **.h** file declares code, and the **.cpp** file implements that declaration
	- tienen extension.h o.hpp.
	- No se compilan, se incluyen en los módulos usados. Al contrario que.cpp

- *LINKER*
	- Takes all the object files generated by the compiler and {; combines} them into a single executable program.

- *g++ hace*:
	- preproceso (includes), la compilacion, enlazado (genera el ejecutable y junta los compilados).
	- ![2023-09-14_14-07-07_pre_comp_link.png](/img/user/_Archivos/2023-09-14_14-07-07_pre_comp_link.png)

- ``#include <headerfile>``
	- Include es una directiva, se sustituye con los contenidos del archivo incluido.
	- se puede separar el código en varios archivos. Se detecta y se compila todo junto.
	- Usar ``#include <iostream>`` para agregar objetos de entrada y salida. (cin, cout)

- **Header guards: IFNDEF Y DEFINE**
	- Son directivas que se usan para evitar incluir varias veces el mismo archivo header.
	- *Todos los headers deben tenerlos*.
	- ``#ifndef NAME`` Mira si un identificador {; no está incluido}, entonces, el codigo hasta ``#endif`` será compilado
	- ``#define NAME`` Marca el header como incluido.

- espacio de Nombres
	- Escribir las funciones del.hpp file dentro de un bloque como "namespace misfunciones" ayuda a que las funciones definidas dentro de él no sean confundidas con funciones con el mismo nombre de fuera de él.
	- Para crear o usar las funciones ahora deberemos acceder a ellas mediante misfunciones::funcion

	- Obviamente dentro de un namespace todas las funciones deben tener distinto nombre

	- Un ejemplo de espacio de nombres es std, usado en cout, string...
	- *using namespace std*  -> nos permite acceder a lo de std sin mencionarilo con su prefijo, puede causar conflictos

# [[1-Referencias/Git\|Git]]

# Variables + Types of Data

- **INSTANTIATION**

	- A variable is a named *object*
	- Variables are used to access memory.
	- Variables have an *identifier* (name), a *type*, and a *value*
{ #73bxc6}

	- the variable will be *instantiated* when the program is run (called runtime)
			- Instantiation means the object will be created and assigned a memory address

	```cpp
	// VARIABLE INITIALIZATION
	int x; // define a variable named x, of type int
	int a, b;  // define multiple variables 
	int a; double b; // correct (but not recommended)
	```

	```cpp
	// WRONG:
	int a, int b;
	int a, double b;
	```

	- *List initialization* produces an error when initializing a variable with a wrong type (useful)

	```cpp
	// VARIABLE ASSIGMENT AND INITIALIZATION
	
	int width; // define an integer variable named width
	width = 5; // copy assignment of value 5 into variable width
	
	int b = 5;     // initializer after equals sign (copy initialization)
	
	int c( 6 );    // initializer in parenthesis (direct initialization)
	
	// List initialization methods (C++11) (preferred)
	int d { 7 };   // initializer in braces (direct list initialization)
	int e = { 8 }; // initializer in braces after equals sign (copy list initialization)
	int f {};      // initializer is empty braces (value initialization)
	```

	- *Initialization* gives a variable an initial value at the point when it is created.
	- *Assignment* gives a variable a value at some point after the variable is created

	- *Default initialization* is when a variable initialization has no initializer (e.g. `int x;`). In most cases, the variable is left with an indeterminate value.
	- *Value initialization* is when a variable initialization has an empty brace (e.g. `int x{};`). In most cases this will perform zero-initialization.
	- *You should prefer value initialization* to default initialization

	```cpp
	// MULTIPLE INITIALIZATION
	int a = 5, b = 6;          // copy initialization
	int c( 7 ), d( 8 );        // direct initialization
	int e { 9 }, f { 10 };     // direct brace initialization (preferred)
	int g = { 9 }, h = { 10 }; // copy brace initialization
	int i {}, j {};            // value initialization
	
	// WRONG
	int a, b = 5; // wrong (a is not initialized!)
	int a, b( 5 );
	```

	*Value Initialization and Zero Initialization { 0 } Vs {}*

	Use an explicit initialization value if you’re actually using that value.

	```cpp
	int x { 0 };    // explicit initialization to value 0
	std::cout << x; // we're using that zero value
	```

	Use value initialization if the value is temporary and will be replaced.

	```cpp
	int x {};      // value initialization
	std::cin >> x; // we're immediately replacing that value
	```

- **TYPES OF DATA**

	- A data type (more commonly just called a type) tells the compiler what type of value (e.g. a number, a letter, text, etc…) the variable will store.
	- C++ also allows you to *create your own* user-defined types

	- ![2023-09-16_12-09-37_datatypes.png](/img/user/_Archivos/2023-09-16_12-09-37_datatypes.png)
	- char: Surround with single quotes
	- *==String==*:
		- Text, double quotes
		- Use import ``<string>`` library
		- Can use + to concatenate. Or *append()* function
		- Can access or modify certain characters using string[n] (python)  or *string[n] = 'm'*
		- auto: automatically detect the type of variable
	- null pointer
	- void: no storage, absence of value (None in python)
	- ==const==: read-only

- **Creating variables**

	```cpp
	int x = 5;
	int y(3);
	int z{2};
	float pi = 3.1416;
	float cash = 2;
	char a = 'a';
	bool is_true = true;
	auto check = false;
	
	```

# Operadores, Logicos, Operaciones...

- Igual que python
- Orden: Parenthesis first, then Exponents, then Multiplication & Division, then Addition & Subtraction

**Logical Operators**

![2023-09-16_12-18-16_logical.png|380](/img/user/_Archivos/2023-09-16_12-18-16_logical.png)

![2023-09-16_12-19-07_and_or_not.png](/img/user/_Archivos/2023-09-16_12-19-07_and_or_not.png)

# Estructuras De Datos

- VECTORES

	- *OPERACIONES BÁSICAS*

		- Needs: `#include <vector>`
		- *Create*
			- ``std::vector<int> v;``  (vacio)
			- ``std::vector<int> v2 = { 2, 3, 5, 7 }``
		- *Access* elements
			- ``v[0]``
				- Careful, because the compiler won't detect if index is incorrect
			- ``v.at(1)``  hace la comprobación de sí el indice está dentro de los limites, genera una excepción si no lo está (usar try-catch)
		- Vector containing x elements with y value
			- ``std::vector<int> data(10);``  (default value: 0)
			- ``std::vector<int> vector3(5, 12);`` (5 elements with value 12)
		- Constant vector
			- ``const std::vector<int> prime { 2, 3, 5, 7, 11 };``
			- Not allowed: ``std::vector<const int> prime { 2, 3, 5, 7, 11 };``  (elements of a non-const vector must be non-const)
		- *Add* elements
			- ``v.push_back(6)``
		- *Delete last* element
			- ``v.pop_back()``
		- *Tamaño* (cantidad elementos)
			- `v.size()`
		- *Recorrer vector*
			- `for (int i = 0; i < v.size(); ++i)`
		- *Ordenar vector*
		- Other functions
			- clear()
			- front()     returns first element
			- back()      last element
			- empty()   boolean
			- capacity()   overall size
		- *Passing parameters by reference and keep it constant*
			- `(const std::vector<int>& v)`
		- Copying an array (independent)
			- `std::vector arr2 { arr1 };`

	- *Reserva de memoria*
		- Interesante si conoces cuantos contendrá
		- `miVector.reserve(100);`

- [CADENAS](https://cplusplus.com/reference/string/string/)

	- Concatenar
		- `std::string result = str1 + str2;`
	- *Convertir número a string*
		- `std::string str = std::to_string(number);`
	- Longitud
		- ``cadena.length()`` o ``cadena.size()``
	- Acceso a elementos o modificar
		- ``c[1]="a"``
			- Esto en python no se puede, pero aquí sí

- MAPS (diccionarios)

	```cpp
	#include <iostream>
	#include <map>
	#include <string>
	#include <utility>  // Para usar make_pair
	
	// Las claves deben ser únicas
	// Se almacenan ordenados por clave
	
	
	int main() {
	    // 1. Creating a Map
	    std::map<int, std::string> studentMap;
		std::map<const int, int> mapaClave    // Clave invariable
		std::map<int, string> student = { {1,"Jacqueline"}, {2,"Blake"}, {3,"Denise"}}
	
	    // 2. Inserting Key-Value Pairs
	    studentMap[101] = "Alice";
	    studentMap[102] = "Bob";
	    studentMap[103] = "Charlie";
	    studentMap.insert(std::make_pair(104, "Juan"))
	
	    // 3. Accessing Values by Key
	    int studentID = 102;
	    std::string studentName = studentMap[studentID];
	    std::cout << "3. Accessing by Key: Student " << studentID << ": " << studentName << std::endl;
	
	    // 4. Checking if a Key Exists
	    int searchID = 104;
	    if (studentMap.find(searchID) != studentMap.end()) {
	        std::cout << "4. Key " << searchID << " exists." << std::endl;
	    } else {
	        std::cout << "4. Key " << searchID << " does not exist." << std::endl;
	    }
	
	    // 5. Iterating Through the Map
	    std::cout << "5. Iterating Through the Map:" << std::endl;
	    for (std::pair <const int, string> item : studentMap) {
	        std::cout << "   Student " << item.first << ": " << item.second << std::endl;
	    }
		    // Con esto se crea un mapa a partir del diccionario, podemos modificar los valores del mapa, pero no el diccionario como tal
	
	    // 6. Removing a Key-Value Pair
	    int removeID = 101;
	    studentMap.erase(removeID);
	    std::cout << "6. Removing a Key-Value Pair: Student " << removeID << " removed." << std::endl;
	
	    // 7. Checking the Size of the Map
	    size_t mapSize = studentMap.size();
	    std::cout << "7. Size of the Map: " << mapSize << " students remaining." << std::endl;
	
	    return 0;
	}
	```

- Conjuntos (sets)

	```cpp
	#include <iostream>
	#include <set>        // Importante
	using namespace std;
	
	int main() {
	    // Create a set
	    std::set<int> mySet;
	
	    // Insert elements
	    mySet.insert(5);
	    mySet.insert(3);
	    // If an element is already added, it will be ignored.
	    mySet.insert(5);
	
	    // Print the set
	    cout << "The elements of the set are: ";
	    for (auto it = mySet.begin(); it != mySet.end(); ++it) {
	        cout << *it << " ";
	    }
	    cout << endl;
	
	    // Erase an element
	    mySet.erase(3);
	
	    // Print the set after erasing
	    cout << "The elements of the set after erasing 3 are: ";
	    for (auto it = mySet.begin(); it != mySet.end(); ++it) {
	        cout << *it << " ";
	    }
	    cout << endl;
	
	    // Check if the set is empty
	    if (mySet.empty()) {
	        cout << "The set is empty." << endl;
	    } else {
	        cout << "The set is not empty." << endl;
	    }
	
	    // Get the size of the set
	    cout << "The size of the set is: " << mySet.size() << endl;
	
	    // Find an element in the set
	    auto search = mySet.find(2);
	    if (search != mySet.end()) {
	        cout << "Found " << *search << '\n';
	    } else {
	        cout << "Not found\n";
	    }
	
	    // Clear the set
	    mySet.clear();
	    
	    return 0;
	}
	```

# Control Flow: If, While, For, Break

[4.10 -- Introduction to if statements](https://www.learncpp.com/cpp-tutorial/introduction-to-if-statements/) y [Control flow introduction](https://www.learncpp.com/cpp-tutorial/control-flow-introduction/)

## Break, Return, Continue

- break: jump out of loop
- Continue: Going to the next iteration

## If, Else If, Else

- Ejemplo

```cpp
if (x > y)
	std::cout << "Una instrucción puede ponerse sin {}";
else if (x == y)
{
	// etc
}
else
{ // note addition of block here
	std::cout << "You are not tall enough to ride.\n";
	std::cout << "Too bad!\n";
}

if (x > 10)
    ; // this is a null statement
```

## Switch

- Bloques if-else muy optimizados
- Condición debe ser un numero unico
- El default se ejecuta si ninguno coincide
- Es importante usar break o return
```cpp
switch (x) // x is evaluated
	{
		case 1:
			std::cout << "One";
			return;
		case 2:
			std::cout << "Two";
			return;
		case 3:
			std::cout << "Three";
			break;
		default:
			std::cout << "Unknown";
			break;
	}
```

==MIRAR MÁS==: [8.6 — Switch fallthrough and scoping – Learn C++](https://www.learncpp.com/cpp-tutorial/switch-fallthrough-and-scoping/)

## Goto

- Used for jumping to a labeled statement in the same function.
- Avoid using it as much as possible (use for, while, do-while)
```c++
#include <iostream>

int main() {
    int x = 0;

    start: // Label
    x++;

    if (x < 5) {
        goto start; // Jump back to the label
    }

    std::cout << "x is " << x << std::endl;

    return 0;
}

```

## For

- The end-expression is evaluated the last in the loop
``` c++
for (init-statement; condition; end-expression)
   {
   statements;
   }
```
- For loops with multiple counter
```c++
#include <iostream>

int main()
{
    for (int x{ 0 }, y{ 9 };    x < 10;    ++x, --y)
        std::cout << x << ' ' << y << '\n';
    return 0;
}
```
- Loop through elements in a list:
```c++
int myNumbers[5] = {10, 20, 30, 40, 50};  
for (int i : myNumbers) {  
  cout << i << "\n";  
}
```

## While

- You can exit infinite loops with return, break, exit, goto
``` c++
#include <iostream>

int main() 
{
    int x = 0;
    // Mientras x menor que 5, sumar 1 a x:
    while (x < 5) {
        x++;
    }
    std::cout << "x is " << x << std::endl;
    return 0;
}
```

## Do-while

- *Executes the code block once before checking conditions*
- Effective for reducing complexity
- Use it as less as possible.
- For showing a menu for example and then asking repeatedly for a number

```c++
#include <iostream>

int main()
{
    // selection must be declared outside of the do-while-loop
    int selection{};

    do
    {
        std::cout << "Please make a selection: \n";
        std::cout << "1) Addition\n";
        std::cout << "2) Subtraction\n";
        std::cin >> selection;
    }
    while (selection != 1 && selection != 2);
}
```

# Entrada y Salida, Ficheros

- **STRING**

	```cpp
	#include <iostream>
	#include <string>
	
	int main() {
	    // 1. Creating and Initializing Strings
	    std::string str1 = "Hello, ";
	    std::string str2 = "world!";
	    
	    // 2. Concatenating Strings
	    std::string greeting = str1 + str2;
	    std::cout << "1. Concatenating Strings: " << greeting << std::endl;
	
	    // 3. String Length
	    std::string text = "This is a sample text.";
	    int length = text.length();
	    std::cout << "2. String Length: " << length << " characters." << std::endl;
	
	    // 4. Accessing Characters
	    char firstChar = text[0];
	    char lastChar = text[length - 1];
	    std::cout << "3. Accessing Characters: First: " << firstChar << ", Last: " << lastChar << std::endl;
	
	    // 5. Substring
	    std::string substring = text.substr(5, 6); // Starting from index 5, take 6 characters
	    std::cout << "4. Substring: " << substring << std::endl;
	
	    // 6. Find and Replace
	    std::string sentence = "Replace the word 'world' with 'universe' in this sentence.";
	    std::string target = "world";
	    std::string replacement = "universe";
	    size_t found = sentence.find(target);
	    if (found != std::string::npos) {
	        sentence.replace(found, target.length(), replacement);
	    }
	    std::cout << "5. Find and Replace: " << sentence << std::endl;
	
	    // 7. Compare Strings
	    std::string str3 = "apple";
	    std::string str4 = "banana";
	    int comparisonResult = str3.compare(str4);
	    if (comparisonResult < 0) {
	        std::cout << "6. Compare Strings: " << str3 << " comes before " << str4 << std::endl;
	    } else if (comparisonResult > 0) {
	        std::cout << "6. Compare Strings: " << str3 << " comes after " << str4 << std::endl;
	    } else {
	        std::cout << "6. Compare Strings: " << str3 << " is equal to " << str4 << std::endl;
	    }
	
	    return 0;
	}
	```

- **STD::COUT, CIN, ENDL, GETLINE**

	```cpp
	#include <iostream>
	#include <string>
	
	int main() {
	    // 1. Output using std::cout
	    int x = 42;
	    std::cout << "1. Output using std::cout: x is equal to: " << x << std::endl;
	
	    // 2. Output with std::endl
	    std::cout << "2. Output with std::endl: Hi!" << std::endl;
	
	    // 3. Input using std::cin
	    int y;
	    std::cout << "3. Input using std::cin: Enter a value for y: ";
	    std::cin >> y;
	    std::cout << "You entered: " << y << std::endl;
	
	    // 4. Input of multiple data in a single line
	    double a, b;
	    std::cout << "4. Input of multiple data in a single line: Enter values for a and b: ";
	    std::cin >> a >> b;
	    std::cout << "You entered a = " << a << " and b = " << b << std::endl;
	
	    ///// 5. Get entire lines as input
	    std::string linea;
	    std::cout << "5. Get entire lines as input: Enter a sentence: ";
	    std::cin.ignore(); // Clear the newline character left in the input buffer
	    std::getline(std::cin, linea);
	    std::cout << "You entered: " << linea << std::endl;
	
	    return 0;
	}
	``` 
	^x8aec2

- **stringstream**

	```cpp
	#include <iostream>
	#include <sstream>  // Importante
	#include <string>
	
	int main() {
	    // Creating a stringstream
	    std::stringstream ss;
	    std::ostringstream oss;
	    std::istringstream iss;
	    std::istringstream ss(text);
	    
	
	    // 1. Basic Usage: Converting Data Types to Strings
	    int num = 42;
	    double pi = 3.14159265359;
	    ss << "Integer: " << num << ", Double: " << pi;
	    std::string result = ss.str();
	    std::cout << "1. Basic Usage: " << result << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 2. Parsing Strings into Data Types
	    std::string data = "123 45.6789";
	    int parsedInt;
	    double parsedDouble;
	    ss.str(data); // Load data into stringstream
	    ss >> parsedInt >> parsedDouble;
	    std::cout << "2. Parsing Strings: Integer: " << parsedInt << ", Double: " << parsedDouble << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 3. Appending to an Existing String
	    ss << "Hello, ";
	    std::string name = "Alice";
	    ss << name << "!";
	    std::string greeting = ss.str();
	    std::cout << "3. Appending to String: " << greeting << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	
		// 4. BUCLES LECTURA DE LINEAS
		std::istringstream flujo_linea(linea);
		while (flujo_linea >> n) {
			// Do something
			// Esto agrega cada "palabra" individual a n, mientras haya
		}
	
	    // 4. Formatting Output
	    double value = 1234.5678;
	    ss << "Value: " << std::fixed << std::setprecision(2) << value;
	    std::string formattedValue = ss.str();
	    std::cout << "4. Formatting Output: " << formattedValue << std::endl;
	    ss.str(""); // Clear the stringstream for reuse
	
	    // 5. Extracting a Substring
	    std::string longText = "This is a long sentence.";
	    ss.str(longText);
	    std::string subString;
	    ss >> subString;
	    std::cout << "5. Extracting Substring: " << subString << std::endl;
	
	    return 0;
	}
	```

- **Ficheros**

	```cpp
	#include <iostream>
	#include <fstream>   // Importante
	#include <string>
	
	int main() {
	    // Create a file object for output
	    std::ofstream outFile("output.txt");
	
	    // Check if the file opened successfully
	    if (outFile) {
	        // Write data to the file
	        outFile << "Hello, Files!" << std::endl;
	
	        // Close the file
	        outFile.close();
	    } else {
	        std::cerr << "Error opening the file." << std::endl;
	    }
	
	    // Create a file object for input
	    std::ifstream inFile("input.txt");
	
	    // Check if the file opened successfully
	    if (inFile) {
	        std::string line;
	        // Read the file line by line
	        while (std::getline(inFile, line)) {
	            if (!line.empty()) {
	                std::cout << "Line: " << line << std::endl;
	            }
	        }
	
	        // Close the file
	        inFile.close();
	    } else {
	        std::cerr << "Error opening the file." << std::endl;
	    }
	
	    return 0;
	}
	
	```

- **NAN**

	```cpp
	#include <iostream>
	#include <cmath>   // importante
	
	int main() {
	    // Create a NAN value
	    double nanValue = std::nan("");
	
	    // Check if a value is NAN
	    if (std::isnan(nanValue)) {
	        std::cout << "The value is NAN." << std::endl;
	    } else {
	        std::cout << "The value is not NAN." << std::endl;
	    }
	    return 0;
	}
	```

- **SETW**, LEFT AND RIGHT

	`#include <iomanip>`
	`outFile << std::setw(10) << "Name" << std::setw(10) << std::endl;`

	- Lo que hace es indicar que la columna ocupara X caracteres, alinea el texto a la derecha

	*seek* (no lo hemos dado)

	- [28.7 — Random file I/O – Learn C++](https://www.learncpp.com/cpp-tutorial/random-file-io/)

# [[3-Resources/Captura y tratamiento de excepciones\|Captura y tratamiento de excepciones]]

# [[3-Resources/OOP, Programación Orientada a Objetos\|OOP, Programación Orientada a Objetos]]

# [[0-Inbox/Punteros y memoria dinámica\|Punteros y memoria dinámica]]

# [[0-Inbox/Costes algorítmicos\|Costes algorítmicos]]

# Cuestiones Random

- **ONE LINE CONDITIONS**:
	- `condition? value_if_true: value_if_false`
	- `std::cout << (veces > 1? " veces": " vez")`
		- Se imprime " veces" si la variable es mayor que 1, y " vez" si no.

- POST / PRE-INCREMENTO
	```cpp
	// PRE-INCREMENTO, antes de evaluar la expresión
	int a = 5;
	int b = ++a; // Ahora, a=6 y b=6
	// POST-INCREMENTO, después de evaluar la expresión
	int a = 5;
	int b = a++; // Ahora, a=6 y b=5
	```

- **Variables locales:**
	- Si se crean dentro de un bloque if/else por ej. solo se pueden acceder desde dentro de él

- **Pasar por referencia**
	- ``int &refNumero = numero;``  // refNumero es una referencia a numero
	- Recibiremos por **referencia `const`** todas las estructuras de datos que sean parámetros de una función (vectores, *strings*, conjuntos, diccionarios...) y no sea un objetivo específico de esa función modificar.

	```cpp
	int numero = 30;
	int &refNumero = numero;  // refNumero es una referencia a numero
	
	refNumero = 40;  // Modificar refNumero también modifica numero
	```


- **EXPRESIONES PELIGROSAS** (vectores):
	`v.size()-1`
	- PROBLEMA: Si `v` está vacío, `v.size()` vale cero y, además, es de un tipo entero sin signo, de tal forma que `0-1` en un tipo así puede dar un resultado grandísimo
	- SOLUCION: asignar `v.size()` a una variable de tipo `int` antes de restarle nada. Si la resta se hace sobre esa variable, un posible resultado negativo se calculará con completa normalidad
		```cpp  
		int i = v.size();
		--i;
		```

	`v[i]`
	- PROBLEMA: Comportamiento indefinido cuando i está fuera del rango válido
	- SOLUCION: Sustituir los accesos `v[i]` por accesos `v.at(i)`
	```cpp  
	while (not v.empty and v[i] == 0) {
	    v.pop_back();
	    --i;
	// C++ es de circuito corto: Si el 1r operando de un and es false, no se evalua el 2o.
	}
	```

- En c++ haremos *copias* al usar el =, a diferencia de python que es una asignación (en listas por ej.)

- Diferencia entre *constructores copia, y asignaciones*
	- COPIA
		- int a = 3, b = 4;
		- int a(3), b(4);
		- int a{3}, b{4};
	- ASIGNACION
		- int a{};
		- a = 3;

- `if (izq)` =  `if (izq!= nullptr)`
	- Siendo izq un puntero.
